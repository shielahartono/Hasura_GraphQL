>> Reference Link :
>> https://hasura.io/docs/3.0/basics/core-concepts

# Core Concepts

- Meluasnya Microservices & API yang harus dihubungkan ke setiap Produk agar dapat berfungsi, telah menimbulkan serangkaian tantangan baru bagi Developer & Architect.

- Di era modern dalam membangun aplikasi, Data Layer menjadi semakin kompleks; Data Layer tidak lagi sekadar Database, tetapi Collection of Database (Kumpulan Database), Services, dan API.

- Hasura DDN memperkenalkan konsep Data Supergraph untuk membantu Anda mengelola kompleksitas ini.

  ## A. The State of The Data Layer
  
Bayangkan beberapa Team berikut dalam sebuah Hypothtethical Company :

>> "Hypothetical" merupakan kondisi berdasarkan teori atau asumsi dan bukan berdasarkan keadaan sebenarnya (actual events). Seringkali digunakan untuk meng-eksplorasi kemungkinan yang terjadi pada situasi tertentu, yang mana pertanyaan tersebut seperti "apa yang anda lakukan jika memenangkan Lotere ?"

>> "Hypothetical Company" merupakan kondisi perumpamaan bisnis yang digunakan sebagai contoh untuk diskusi, analisis, dan sebagainya

(1) Product Management Team :

- bertanggung jawab atas 'Relational Database' yang menyimpan informasi Produk.
yang mana Team ini fokus pada Cataloging Products (Pengkatalogan Produk), Managing Inventory, dan memastikkan Detail Produk dalam keadaan Akurat & up-to-date dengan menggunakan Relational Database PostgreSQL.

(2) User Experience Team : 

- Mengelola Dokumen Database MongoDB dan API terkait untuk menyimpan User Information.
Fokusnya mereka adalah Maintaining User Profile, Preferences, dan memastikkan privasi dan Security dari data pengguna.

(3) Search Optimization Team : 

- Menangani integrasi Algolia Search Services untuk Product dan Partner Store. Mereka bekerja untuk mengoptimalkan algoritme pencarian, memastikan hasil pencarian yang relevan, dan meningkatkan pengalaman pencarian secara keseluruhan bagi User.

(4) Finance & Transactions Team : 

- Mengawasi Stripe Payment Service (layanan pembayaran Stripe) dan Relational Database yang mendasarinya untuk memproses pembayaran,
yang mana hal ini termasuk mengelola keamanan transaksi (Managing Transaction Security) , integrasi Payment Gateway, dan memastikan Transaksi Keuangan yang lancar.

- Payment Gateway itu seperti "Online Bridge" (jembatan Online) yang membantu kita melakukan pembelian di internet.

- Payment Gateway merupakan Technology yang memfasilitasi Online Transactions dengan mengirim informasi pembayaran secara aman antara Customer, Merchant (Pedagang), dan Bank.
Payment Gateway memastikkan bahwa Data Sensitif dilakukan enkripsi, dan diproses dengan aman.
(Data Sensitif tersebut seperti Credit Card Numbers, Credit Card Details)


(5) Logistics and Shipping Team : 

- Bertanggung jawab atas layanan pengiriman ShipStation, pemenuhan pesanan (Fulfilling Orders), dan Relational Database yang mendukung proses ini. Fokus utama mereka adalah logistik, pelacakan pesanan (Order Tracking) , dan memastikan pengiriman produk tepat waktu.


(6) Data Science and Recommendations Team :

- Mengelola Weaviate Vector Database untuk menyimpan User Recommendation. 
Mereka mengerjakan Personalization Algorithms, analisis User Behavior, dan memberikan Product Recommendations untuk meningkatkan User Experience.


>> --
>> --

Keragaman Team dalam perusahaan ini, masing-masing dengan fokus unik dan Data Service yang terspesialisasi, melambangkan Challenge yang terjadi dalam Pengelolaan Data secara modern dan Pengembangan API

Semua Team ini beroperasi dengan API, Schemas, dan Metodologi yang berbeda,
yang mana Fragmentasi atau Perbedaan ini tidak hanya memperumit Proses Pengembangan Aplikasi, tetapi juga memerlukan keterlibatan Data Architect & Data Engineer untuk mengintegrasikan dan memelihara berbagai sumber data secara efisien.

(Fragmentasi merupakan Perbedaan pada Aplikasi atau Software)


### 1. What is "The Data Layer" ?
>> Penjelasan tambahan di luar Dokumentasi Hasura

- Pada aplikasi apapun, "Data Layer" merupakan tempat aplikasi berinteraksi dengan Database.

- "Data Layer" menangani "Storage" (Penyimpanan), Retrieval (Pengambilan), and "Manipulation" (manipulasi) of Data

(Data Layer menangani Penyimpanan, Pengambilan, dan Manipulasi Data)

- "Data Layer" sangat penting, karena :

	(1) memastikkan  Aplikasi dapat memperoleh Data.

	(Data Layer makes sure "App can get Data")
	
	(2) memastikkan Aplikasi dapat mengirim Data baru ke Database

	(Data Layer makes sure "App can send new Data to the Database")


### 2. How Does Hasura Manage "The Data Layer" ?
### (Bagaimana Hasura mengelola "Data Layer" ? )
>> Penjelasan tambahan di luar Dokumentasi Hasura

- Hasura mengelola "Data Layer" dengan secara otomatis membuat "GraphQL API" untuk Database anda.
yang mana, ini berarti, pada saat kita membuat Database ke Hasura, 
Hasura membuat serangkaian alat yang memungkinkan anda membuat Query & memodifikasi Data tanpa perlu membuat API secara manual.

#### 2.1) Berikut ini yang dilakukan Hasura pada "Data Layer" :

##### [1] Instant API Generation : 

-> Begitu kita connect ke Database, Hasura secara otomatis membuat "GraphQL API".
yang mana kita bisa langsung membuat "Query" (asking for Data) dan Mutation (changing data) menggunakan API ini.

-> API (Application Programming Interface) merupakan cara berbagai Software yang berbeda untuk berkomunikasi dengan satu sama lain.

Pada konteks Hasura, API memungkinkan aplikasi kita (seperti Web atau Mobile App) untuk berkomunikasi dengan Database atau untuk mendapatkan Data atau Memperbarui Data.

-> Biasanya (pada case bukan Hasura), Developer perlu membuat API secara manual agar aplikasi bisa berinteraksi dengan Database.
yang mana hal ini melibatkan penulisan Backend Code, Setting Up Route (Pengatura Rute), dan memastikkan Keamanan, yang mana tugas-tugas tersebut dapat menyita banyak waktu dan tenaga.

-> Pada Hasura, "Instant API Generation" secara otomatis membuat API, segera setelah kita menghubungkan ke Database, tanpa kita perlu menulis Backend Code


##### [2] Permissions : 

-> Hasura memungkinkan kita untuk menetapkan "Fine-Grained" Access Control Rules (aturan kontrol Akses yang terperinci), sehingga User atau Role yang berbeda dapat memiliki tingkat akses yang berbeda ke Data kita.
yang mana, hal ini memastikkan Keamanan dengan hanya mengizinkan orang yang berwenang untuk melihat atau mengubah tertentu.

>> ^For your Information^ 
>>
>> {1} **Fine-Grained Access Control** :
>> 
>> -> "Fine-Grained Aceess Control" (FGAC) merupakan Security approach yang memungkinkan kita untuk menetapkan aturan yang "Sangat Spesifik" tentang siapa yang dapat mengakses Data atau Fitur dalam suatu System.

>> -> Keyword :
>> "Fine-Grained Aceess Control" (FGAC) = aturan Access Control yang sangat spesifik
 
>> -> berbeda dengan "Coarse-Grained Access Control" yang menyediakan izin yang luas tanpa aturan yang spesifik.
>> Seperti "Everyone can accesss the Data", "All Students can Access the book"

>> -> Contoh : School Library

>> (1) Coarse-Grained Access :
>> All Students dapat meminjam buku

>> (2) Fine-Grained Access Control : 

>> Elementary School Students (Siswa SD) hanya bisa meminjam buku dari Kid's Section.

>> Middle School Students (Siswa SMP) dapat meminjam buku dari Kid's Section & Young Adult Section.

>> Teachers (Guru) dapat mengakses semua Book Section.


>> -> Use Case (Kasus Penggunaan) :

>> (1) Database Security :
>> Membatasi akses pengguna ke Row (baris) atau Kolom yang spesifik pada Database Table.
>> seperti, ada Baris tertentu pada Database Table yang hanya boleh diakses oleh Admin.

>> (2) Application Security :
>> Mengontrol Akses berdasarkan User Roles.
>> yakni setiap Roles mempunyai izin yang berbeda untuk mengakses Fitur atau Data tertentu.

>> (3) Resource Management :
>> Mengelola akses ke File, Folder, atau Services berdasarkan User Roles, Location, atau Faktor lainnnya


##### [3] Real Time Data :

-> Hasura menawarkan "Subscription" di GraphQL yang menyediakan Real-Time Update.

Jika ada yang berubah pada Database, aplikasi yang terhubung ke Hasura dapat secara otomatis diperbarui dengan Data baru tanpa perlu melakukan Refresh secara manual.

>> ^For your Information^
>> 
>> {1} **Subscription** :
>> 
>> -> Subscription adalah fitur canggih yang memungkinkan kita mendapatkan "Real-Time Updates" dari Database.
artinya, saat terdapat perubahan pada Database, aplikasi kita akan secara otomatis menerima Update tanpda perlu melakukan Refresh atau Request tambahan lainnya.
>>
>> -> Contoh Query Subscription pada Hasura :
>>
>> misalnya kita mempunyai Table di Database yang bernama "Posts",
>> dan kita ingin menampilkan Real-Time Updates saat terdapat perubahan pada Tabel "Posts".
>>
>> (1)  Berikut ini adalah contoh Query untuk GraphQL Subscription ke Tabel Posts : 
>>
>>```graphql
>>subscription {
>>  posts {
>>    id
>>    title
>>    content
>>    created_at
>>  }
>>}
>>```
>><br/>
>> (2) Contoh Query untuk Subscribes ke Tabel Messages : <br/>
>> jika terdapat perubahan Data pada Tabel Messages (Seperti mendapatkan Pesan/Message baru), kita akan mendapatkan Update pada Data tersebut secara Real-Time.
>> 
>> ```
>> subscription {
>>  messages(where: { chat_room_id: { _eq: 1 } }) {
>>    id
>>    content
>>    user
>>    created_at
>>  }
>> }
>> ```
>> <br/>
>> <br/>
>> 
>> ````
>> (where: { chat_room_id: { _eq: 1 } })
>> ````
>> potongan Query diatas artinya "dimana nilai chat_room_id adalah 1",
>> yang mana ini berarti jika terdapat Messages baru pada "Chat Room 1", maka berikan notifikasi nya pada Aplikasi saya.
>> <br/>
>> <br/>
>> <br/>
>> (3) Contoh Query untuk Subscribes ke Tabel "StockPrices" (harga saham) : <br/>
>> Contoh Query untuk Subscribes ke Tabel StockPrices (harga Saham), tapi hanya ke Spesifik Saham, yaitu Saham AAPL.
>>yakni jika terdapat perubahan harga Saham pada sahama AAPL, kita akan mendapatkan notifikasi mengenai Update Data tersebut secara Real-Time.
>>
>> ```
>>subscription {
>>  stockPrices(where: { symbol: { _eq: "AAPL" } }) {
>>    symbol
>>    price
>>    updated_at
>>  }
>>}
>>```
>> <br/>
>> <br/>
>>
>> ```
>> (where: { symbol: { _eq: "AAPL" } })
>> ```
>>  <br/>
>>potongan Query diatas artinya "dimana nilai Symbol adalah AAPL", (AAPL itu merupakan kode untuk Saham Apple) <br/>
>> yang mana ini berarti berikan saya notifikasi nya jika terdapat perubahan harga pada Saham AAPL.
>> <br/>
>> <br/>
>> <br/>
>>  -> Cara Kerja "Subscription" di Hasura :

>> (1) Client Subscribes : <br/>
>> Client yang berupa Front-end Application pada Hasura, mengirim "Query GraphQL Subscription".
>> Query tersebut dibutuhkan untuk track changes (melacak perubahan). <br/>
>>Misalnya jika kita ingin mendapatkan Real-Time Update mengenai Tabel "Message",
>>maka kita akan Subscribe ke Tabel "Message" tersebut.
>>
>>  (2) Hasura Listens For Change : <br/>
>> Setelah Subscription aktif, <br/>
>> kemudian Hasura memantau Database untuk setiap perubahan (seperti New Messages, Updated Records, atau Deleted Data).
>>
>> (3) Real-Time Updates : <br/>
>> Saat terdapat perubahan pada Database, <br/>
>> Hasura secara otomatis "Push the updated Data" (Push data yang di-update) ke Aplikasi secara Real-Time.
>> yang mana dengan hal ini, Aplikasi tidak perlu mengirim Request baru atau melakukan Refresh Page untuk mendapatkan Data yang baru.
>> <br/>
>> <br/>
>> <br/>
>> <br/>
>> -> Contoh Penggunaan Subscription :
>>
>> Jika kita membangun Chat App (Aplikasi Chat),
>> kita bisa melakukan "Subscribe" ke Tabel "Messages",
>> sehingga kapanpun ada Pesan baru, maka Pesan tersebut akan langsung muncul ke Aplikasi tanpa harus Reload Page (memuat ulang halaman).
>> 
>> (Tabel "Messages" berisi data mengenai Pesan Chat, sehingga saat ada Pesan baru masuk, maka data pada Tabel "Messages" mengalami perubahan).
>>
>> -> How Hasura Manage Subscription :
>> (Cara Hasura mengelola Subscription)
>>
>> Hasura menangani Subscription menggunakan "WebSockets".
>>
>> WebSockets merupakan teknologi yang memungkinkan komunikasi dua arah (two-way communication) antara Server dan Client.
>> yang mana hal ini memungkinkan Hasura untuk menjaga Open Connection (komunikasi yang berkelanjutan untuk menerima informasi) dan melakukan Push Updates kapanpun terjadi >> perubahan pada Database.
>>
>>
>> -> begini cara kerja Subscription : 
>>
>> (1) Saat aplikasi kita memulai Subscription, maka koneksi WebSocket dibuka antara Hasura dan aplikasi kita.
>>
>> (2) Selama Koneksi WebSocket ini aktif, Hasura dapat mengirim Update ke aplikasi kapanpun data mengalami perubahan
>> 
>> (3) Jika Koneksi WebSocket nya Lost (terputus) atau Closed (ditutup),
>> maka aplikasi dapat melakukan Restart pada Subscription untuk bisa menerima Update (Perubahan Data).
>><br/>
>><br/>
>> <br/>
>>-> Use Case for Subscription :
>> (Kasus penggunaan untuk Subscription)
>> 
>> Subscriptions sangat berguna untuk fitur Real-Time pada Aplikasi.
>>
>> Beberapa contoh Use Case Subscription, yaitu : 
>>
>> (1) Live Chat : <br/>
>> Dapatkan Pesan baru secara instan dalam percakapan, tanpa harus melakukan Refresh pada halaman.
>> 
>> (2) Live Notifications : <br/>
>> Menampilkan Notifikasi segera setelah Event baru terjadi.
>> Event tersebut seperti Comments, Likes, Messages.
>>
>> (3) Collaborative Tools : <br/>
>> Jika beberapa orang sedang mengerjakkan sebuah dokumen yang sama,
>> maka Subscription dapat menunjukkan Real-Time Update dari User lain. <br/>
>> Contohnya seperti Google Doc.
>> Misalnya Putri dan Jane sedang mengerjakkan file yang sama pada Google Doc,
>> maka dengan Subscription, Putri dapat melihat perubahan data pada dokumen yang dilakukan oleh Jane. begitu juga sebaliknya, Jika Putri menambah tulisan pada Goolge Doc, >> maka Jane dapat melihat tulisan oleh yang diubah oleh Putri.
>> 
>> (4) Real-Time Dashboards : <br/>
>> Track (Melacak) Live Data pada sebuah Dashboard,
>> seperti Stock Prices, Metrices, atau Data dari Sensor.
>>
>>   -> Workflow of Subscriber in Hasura : <br/>
>> 	(Alur Kerja Subscriber di Hasura)
>> 
>> ![Cara Kerja of Subscriber in Hasura drawio](https://github.com/user-attachments/assets/930cf6bf-c8a9-4609-84fd-0aaf0746d003)
>> <br/>
>> Berikut ini Cara Kerja / Alur Kerja Subscriber di Hasura : <br/>
>> (Penjelasan Chart)
>> <br/>
>> <br/>
>> (1) Client 1 & Client 2 : <br/>
>> Bagian ini mewakili dua User (Client) yang berbeda dari aplikasi kita yang ingin menerima Real-Time Updates.  <br/>
>> Masing-masing Clients mempunyai "WebSocket" Connection ke Hasura Server.
>> 
>> (2) WebSocket Connection :  <br/>
>> Setiap Client memelihara koneksi WebSocket (WebSocket Connection) yang memungkinkan mereka untuk menerima Update secara Real-Time.  <br/>
>> (Client perlu menjaga Koneksi pada WebSocket tetap aktif untuk bisa menerima Update secara Real-Time).
>> 
>> (3) Subscribe to "The Data Changes" :  <br/>
>> Clients (baik Client 1, maupun Client 2 pada gambar) melakukan Subscribes untuk Perubahan Data tertentu (Data Changes tertentu),  <br/>
>> yang mana hal ini dilakukan dengan mengirimkan "Subscription Query" (Query untuk minta Subscription) ke Server Hasura. <br/>  <br/>
>> yang dimaksud dengan "Client Subscribes to Spesific Data Changes", <br/>
>> itu berarti Client memberitahu Server untuk segera memberikan Notifikasi saat terjadi perubahan mengenai Data Spesifik tersebut. <br/>
>> Contoh :  <br/>
>> Kita Subscribes ke Tabel "StockPrices" (harga saham), tapi hanya untuk spesifik Data, yaitu Saham Apple. <br/>
>> maka kita hanya akan diberi notifikasi jika terdapat perubahan harga pada saham Apple, <br/>
>> dan tidak diberi notifikasi jika terdapat perubahan harga pada saham lainnya. <br/>
>> <br/>
>> <br/>
>> (4) Hasura Server : 
>> <br/>
>> Hasura Server listens (mendengarkan) setiap Perubahan pada Data yang di-Subscribes.
>> yang mana, Hasura Server akan diberi tahu jika terdapat perubahan pada data tersebut.
>> <br/>
>> <br/>
>> (5) Data Changes : <br/>
>> Hasura Server mendeteksi adanya perubahan pada Database, <br/>
>> kemudian Hasura Server bersiap untuk mengirimkkan Update mengenai Perubahan Data.
>>  <br/>
>>  <br/>
>> (6) Updates Sent :  <br/>
>> Hasura Server mengirim Update ke semua Connected Clients yang melakukan Subscribes ke Data tersebut.
>> <br/>
>> <br/>
>> (7) Notify Clients :  <br/>
>> Client menerima Update Data melalui WebSocket Connection mereka masing-masing
>> (Setiap Client mempunyai WebSocket Connection),  <br/>
>> untuk memastikkan Data mereka tetap Sinkron dengan Server secara Real-Time
>> <br/>
>>  <br/>
>> -> Summary Cara Kerja Subscriber di Hasura :  <br/>
>> (1) Client menjaga agar "WebSocket Connection" tetap aktif agar bisa menerima Update Perubahan Data secara Real-Time  <br/>
>> (2) Client mengirimkan "Subscription Query" untuk melakukan Subscribes ke Perubahan Data tertentu.  <br/>
>> (3) Hasura Server "Listens" (mendengarkan) setiap perubahan pada Data yang di-subscribes.  <br/>
>> (4) Hasura Server mendeteksi adanya perubahan pada Data.  <br/>
>> (5) Hasura Server mengirim perubahan data ke semua Client yang terhubung (Connected Clients) yang melakukan Subscribes ke Data tersebut.  <br/>
>> (6) Setiap Client menerima Update Perubahan Data melalui WebSocket Connection mereka masing-masing  <br/>
>>
>>  -------
>> {2} **WebSocket**
>>
>>  -> WebSocket merupakan "Communication Protocol" yang memungkinkan interaksi dua arah (two-way communication) yang berkelanjutan antara Client dan Server. <br/>
>> tidak seperti metode komunikasi tradisional (Traditional Communication Method) seperti HTTP, dimana Client harus berulang kali membuat Request untuk mendapatkan Update >> dari Server.
>>
>> -> WebSocket menyediakan cara untuk menjaga Connection tetap Open dan Aktif, <br/>
>> agar Data bisa mengalir bebas di kedua arah.
>>
>> -> Cara Kerja WebSocket :  <br/>
>> (How WebSocket works)
>>
>> (1) Initial Connection (Koneksi awal) : <br/>
>> Initial Connection dimulai dengan Client (seperti "Web Browser") yang membuat HTTP Request Standard ke Server. <br/>
>> Request meminta untuk meningkatkan Connection ke WebSocket, <br/>
>> yang mana jika Server mendukung WebSocket, maka Server setuju untuk meningkatkan Connection ke WebSocket, dan Connection didirikan.
>> <br/>
>> <br/>
>> (2) Full-Duplex Communication : <br/>
>> "Full-Duplex" sendiri memiliki arti yaitu Data dapat dikirim & diterima dalam dua arah secara serentak,<br/>
>> yang mana contohnya adalah Telephone Conversations (Percakapan Dua arah).<br/>
>> <br/>
>> (for your information, "Half-Duplex" sendiri berarti Data dapat dikirim dalam dua arah, tetapi tidak secara serentak, contohnya adalah Percakapan Walki-Talkie) <br/>
>> <br/>
>> Setelah "WebSocket Connection" didirikan, Client & Server dapat mengirim dan menerima Data kapan saja.<br/>
>> Dan Client tidak perlu terus meminta Server untuk Update (seperti dalam "Traditional HTTP" yang perlu terus meminta Server untuk Update). <br/>
>> <br/>
>> WebSocket Connection tetap terbuka hingga Client atau Server memutuskan untuk menutupnya.
>> <br/>
>> <br/>
>> (3) Real-Time Data Exchange : <br/>
>> Karena WebSocket memiliki Connection yang selalu terbuka (Open), <br/>
>> maka WebSocket ideal untuk Aplikasi Real-Time yang mengharuskan Data untuk dikirim atau diterima secara instant.<br/>
>> <br/>
>> Aplikasi Real-Time tersebut seperti Online Games, Chat Applications, Live Sports Updates, Stock Trading Platform, Collaborative Tools (seperti Google Doc).
>> <br/>
>> <br/>
>> -> Key Features of WebSocket :<br/>
>> (Fitur Utama WebSocket)<br/>
>> <br/>
>> (1) Persistence Connection :<br/>
>> WebSocket memiliki Koneksi yang tetap terbuka.<br/>
>> Koneksi WebSocket tetap terbuka hingga Client atau Server memutuskan untuk menutup Koneksi tersebut.<br/>
>> <br/>
>> (tidak seperti HTTP yang Koneksi ditutup setelah setiap kali Server mengirim Response.
>> Sehingga pada HTTP, Koneksi baru harus selalu dibuat setiap kali Client melakukan Request ke Server )  <br/>
>>  <br/>
>> (2) Low Latency :  <br/>
>> Latency dapat dikurangi karena tidak perlu membuka Koneksi baru berkali-kali untuk Data yang dikrimkan,  <br/>
>> sehingga Data Transfer (pengiriman data menjadi lebih cepat). <br/>
>> <br/>
>> (3) Two- Way Communication : <br/>
>> Client & Server dapat mengirim message ke satu sama lain, kapanpun tanpa menunggu. <br/>
>> <br/>
>> (4) Efficient : <br/>
>> Menggunakan lebih sedikit overhead data dibandingkan dengan HTTP Request, sehingga lebih cocok untuk transfer data real-time dan frekuensi tinggi.<br/>
>> (Overhead Data adalah Extra Information yang dikirim bersama dengan Actual Content)
>>
>> -> Comparison with HTTP :  <br/>
>> (Perbandingan/Perbedaan WebSocket dengan HTTP) : <br/>
>>  <br/>
>> HTTP : <br/>
>> pada HTTP, Client harus berulang kali meminta Update (disebut Polling),  <br/>
>> yang mana hal ini dapat menyebabkan Delay & tidak efektif pada Real-Time Data. <br/>
>>  <br/>
>> WebSocket : <br/>
>> Server dapat langsung mengirim ke Client setelah segera Data baru tersedia, tanpa perlu Client me-request nya. <br/>
>>  <br/>
>>  <br/>
>>  -> Workflow of WebSocket in Hasura :  <br/>
>> (Alur Kerja WebSocket di Hasura)
>>
>>  ![WebsSocket WorkFlow in Hasura drawio](https://github.com/user-attachments/assets/269d4d9f-3b27-4b47-9f44-8f5563a16ced)
>> <br/>
>>  Workflow WebSocket itu mirip dengan Workflow Subscription :
>> <br/>
>><br/>
>> (1) Client 1 & Client 2 : <br/>
>> Bagian ini mewakili dua User (Client) yang berbeda dari aplikasi kita yang ingin menerima Real-Time Updates.  <br/>
>> Masing-masing Clients mempunyai "WebSocket" Connection ke Hasura Server.
>> 
>> (2) WebSocket Connection :  <br/>
>> Setiap Client memelihara koneksi WebSocket (WebSocket Connection) yang memungkinkan mereka untuk menerima Update secara Real-Time.  <br/>
>> (Client perlu menjaga Koneksi pada WebSocket tetap aktif untuk bisa menerima Update secara Real-Time).
>> 
>> (3) Subscribe to "The Data Changes" :  <br/>
>> Clients (baik Client 1, maupun Client 2 pada gambar) melakukan Subscribes untuk Perubahan Data tertentu (Data Changes tertentu),  <br/>
>> yang mana hal ini dilakukan dengan mengirimkan "Subscription Query" (Query untuk minta Subscription) ke Server Hasura. <br/>  <br/>
>> yang dimaksud dengan "Client Subscribes to Spesific Data Changes", <br/>
>> itu berarti Client memberitahu Server untuk segera memberikan Notifikasi saat terjadi perubahan mengenai Data Spesifik tersebut. <br/>
>> Contoh :  <br/>
>> Kita Subscribes ke Tabel "StockPrices" (harga saham), tapi hanya untuk spesifik Data, yaitu Saham Apple. <br/>
>> maka kita hanya akan diberi notifikasi jika terdapat perubahan harga pada saham Apple, <br/>
>> dan tidak diberi notifikasi jika terdapat perubahan harga pada saham lainnya. <br/>
>> <br/>
>> <br/>
>> (4) Hasura Server : 
>> <br/>
>> Hasura Server listens (mendengarkan) setiap Perubahan pada Data yang di-Subscribes.
>> yang mana, Hasura Server akan diberi tahu jika terdapat perubahan pada data tersebut.
>> <br/>
>> <br/>
>> (5) Data Changes : <br/>
>> Hasura Server mendeteksi adanya perubahan pada Database, <br/>
>> kemudian Hasura Server bersiap untuk mengirimkkan Update mengenai Perubahan Data.
>>  <br/>
>>  <br/>
>> (6) Updates Sent :  <br/>
>> Hasura Server mengirim Update ke semua Connected Clients yang melakukan Subscribes ke Data tersebut.
>> <br/>
>> <br/>
>> (7) Notify Clients :  <br/>
>> Client menerima Update Data melalui WebSocket Connection mereka masing-masing
>> (Setiap Client mempunyai WebSocket Connection),  <br/>
>> untuk memastikkan Data mereka tetap Sinkron dengan Server secara Real-Time
>> <br/>
>>  <br/>
>> -> Summary Cara Kerja WebSocket di Hasura :  <br/>
>> (1) Client menjaga agar "WebSocket Connection" tetap aktif agar bisa menerima Update Perubahan Data secara Real-Time  <br/>
>> (2) Client mengirimkan "Subscription Query" untuk melakukan Subscribes ke Perubahan Data tertentu.  <br/>
>> (3) Hasura Server "Listens" (mendengarkan) setiap perubahan pada Data yang di-subscribes.  <br/>
>> (4) Hasura Server mendeteksi adanya perubahan pada Data.  <br/>
>> (5) Hasura Server mengirim perubahan data ke semua Client yang terhubung (Connected Clients) yang melakukan Subscribes ke Data tersebut.  <br/>
>> (6) Setiap Client menerima Update Perubahan Data melalui WebSocket Connection mereka masing-masing  <br/>
>> <br/>
>> <br/>
>>  -> WebSocket Server :  <br/>
>>  WebSocket Server merupakan System yang menangani WebSocket Connection yang masuk dari Client.  <br/>
>>  WebSocket Server mendengarkan (Listens) WebSocket Request yang baru, menerima Connections, kemudian mengelola Real-Time Communications antara Server dan Client.  <br/>
>>   <br/>
>>  -> Fungsi WebSocket Server : <br/>  <br/>
>>  (1) Accepts Connection :  <br/>
>>  Saat Client mengirim WebSocket Connection Request,  <br/>
>>  WebSocket Server menerima atau menolak WebSocket Connection Request.  <br/>
>>   <br/>
>>  (2) Manages Communication :  <br/>
>>  Setelah Connection berhasil didirikan, WebSocket Server mengelola komunikasi antara dirinya dengan Client yang terhubung.  <br/>
>>  WebSocket Server dapat mengirim Pesan ke Client, menerima Pesan dari Client, dan menyiarkan (broadcast) updates ke Multiple Clients secara bersamaan.  <br/>
>>   <br/>
>>  (3) Handles Multiple Clients :  <br/>
>>  Sebuah WebSocket Server dapat menangani Beberapa WebSocket Connection dalam waktu yang sama.  <br/>
>>  yang mana ini berarti, banyak Clients dapat terkoneksi ke WebSocket Server secara bersamaan (simultaneously) untuk menerima Real-Time Updates.  <br/>
>>  (Lebih dari satu Client dapat terhubung ke satu WebSocket Server secara bersamaan )  <br/>
>>
>> -------
>> {3} **Traditional HTTP Response** <br/>
>> <br/>
>> -> "Traditional HTTP Request" merupakan cara bagi Client (seperti Web Browser) untuk berkomunikasi dengan Server untuk meminta Data atau mengirim Informasi. <br/>
>> "Traditional HTTP Request" mengikuti "Request-Response Model" dimana Client mengirimkan sebuah Request dan Server mengirim kembali sebuah Reponse.  <br/>
>>  <br/>
>> -> There are two-key players "Traditional HTTP Request" :  <br/>
>>  (Dua pemain kunci pada "Traditional HTTP Request")
>>   <br/>
>>   <br/>
>> (1) Client : <br/>
>>  Biasanya Client berupa Web Browser atau App (Front-End Applications yang biasa dipakai oleh User), <br/>
>>  yang Client tersebut ingin mengambil Data (Fetch Data) atau mengirim informasi ke Server.  <br/>
>>   <br/>
>>  (2) Server : <br/>
>>  Server menyimpan Resources (seperti Web Pages, Images, atau Data)  <br/>
>>  dan juga Server memproses Client's Request.
>> <br/>
>>  <br/>
>> -> Cara Kerja "Traditional HTTP Request" :  <br/>
>>  <br/>
>> (1) Client Sends a Request :  <br/>
>> Clent mengirim "HTTP Request" ke Server.  <br/>
>> Request dapat berupa hal yang berbeda, seperti :  <br/>
>>  <br/>
>> GET :  <br/>
>> untuk meminta Data (seperti Loading halaman Web. image, ataU API Data).  <br/>
>>  <br/>
>> POST : <br/>
>> untuk mengirim Data ke Server (seperti Mengumpulkan Form).  <br/>
>>  <br/>
>> PUT :  <br/>
>> untuk meng-update Data.  <br/>
>>  <br/>
>> DELETE :  <br/>
>> untuk menghapus Data
>>  <br/>
>>  <br/>
>> (2) Server Receives The Request :  <br/>
>> Server memproses Request dan menentukkan Data atau Resource yang mana yang akan dikembalikan ke Client.  <br/>
>>  <br/>
>> (3) Server Sends a Response :  <br/>
>> Setelah memproses Request, Server mengirim kembali sebuah Response.  <br/>
>> yang mana Response tersebut mengandung :  <br/>
>> (Response yang dikirim bali oleh Server ke Client, mengandung hal berikut ini : )  <br/>
>>  <br/>
>>	 - Status Code :  <br/>
>> 	Status Code mengindikasikan apakah Request nya berhasil, atau apakah Request Error.  <br/>
>> 	Contoh Status Code jika Request berhasil = 200 OK , dan sebagainya.  <br/>
>> 	Contoh Status Code jika Request error = 404 Not Found , dan sebagainya.  <br/>
>> 
>>	 - Data :   <br/>
>> 	Jika Request tersebut untuk meminta Data (seperti WebPage atau API),  <br/>
>> 	maka Server mengirim kembali Informasi yang di-request.  <br/>
>>  <br/>
>> (4) Connection Closes :  <br/>
>> Koneksi ditutup setelah Server memberikkan Responds.  <br/>
>> Sehingga Client harus membuat Request baru jika memerlukkan lebih banyak data. <br/>
>> <br/>
>>  <br/>
>> -> One-Time Request and Response : <br/>
>>   <br/>
>>  Pada "Traditional HTTP Request", Communication nya adalah "One-Time" (satu kali),  <br/>
>>  yang berarti :  <br/>
>>  
>>  - Client meminta Data, Server memberikan Reponse, kemudian Communication selesai.  <br/>
>> 
>>  - Jika Client membutuhkan Lebih banyak Data atau Informasi ter-Update,  <br/>
>>  maka Client harus mengirim Request Baru.  <br/>
>>   <br/>
>>  Sebagai contoh :  <br/>
>>  Jika kita ingin membaca Article pada 'Halaman Web', maka Browser (Client) kita mengirim sebuah Request ke Server untuk meminta Halaman Web tersebut,  <br/>
>>  Dan Server memberi Response dengan mengirim Data mengenai Article pada Halaman web tersebut, Kemudian Connection tertutup.  <br/>
>>  Sehingga jika terdapat "Page Update", kita harus melakukan "Refresh" pada Halaman Web untuk mengirim Request Baru,  <br/>
>>  setelah itu, baru kita mendapatkan Halaman Web dengan informasi yang sudah diperbarui.  <br/>
>>  <br/>
>>  <br/>
>> -> Stateless Communication :  <br/>
>>  <br/>
>> HTTP Request bersifat "Stateless",  <br/>
>> yang berarti setiap Request bersifat "Independent" yang artinya Server tidak ingat 'Request Sebelumnya'.  <br/>
>> sebagai contoh :  <br/>
>> Jika kita memuat satu halaman Web, kemudian kita Clik link pada halaman Web tersebut untuk memuat halaman Web yang berbeda,  <br/>
>> Kedua Request untuk memuat Halaman Web tersebut ditangani secara terpisah.  <br/>
>> yang mana Server tidak melacak Riwayat penelusuran kita, kecuali menggunakan Mekanisme khusus seperti "Cookies".  <br/>
>>   <br/>
>> -> Advantages of Traditional HTTP Requests :   <br/>
>> (Kelebihan "Traditional HTTP Requests")   <br/>
>>   <br/>
>> (1) Simple & Efficient :   <br/>
>> Bekerja sangat baik untuk Simple Actions (Actions sederhana) seperti Memuat Halaman Web atau Submitting a Form.  <br/>
>>   <br/>
>> (2) Wide Compatibility :   <br/>
>> merupakan Backbone (tulang punggung) bagaimana Web bekerja,   <br/>
>> dan semua Web Browser & Server memahami HTTP.   <br/>  <br/>
>>
>> -> Limitations of Traditional HTTP Request :  <br/>
>> (Keterbatasan "Traditional HTTP Request")  <br/>
>> 
>> (1) No Real-Time Updates :  <br/>
>> Setelah Server memberikan Respnse, maka Connection ditutup. <br/>
>> Jika terdapat Perubahan Data, maka Client harus mengirim "Request Baru" untuk medapatkan Data terbaru. <br/>
>> yang mana hal ini dapat menjadi inefficient untuk Aplikasi Real-Time. <br/> <br/>
>>
>> (2) Polling Needed for Updates : <br/>
>> (dibutuhkan "Polling" untuk Updates) <br/>
>> <br/>
>> Pada HTTP, jika membutuhkan Real-Time Data, biasanya digunakan "Polling" untuk mengecek Perubahan Data. <br/>
>> tetapi "Polling" dapat menambah beban pada Server dan tidak efficient.<br/>
>> <br/>
>> Polling pada HTTP merupakan sebuah Method yang digunakan oleh Client (seperti Web Browser) untuk memeriksa Pembaruan Data di Server secara berkala. <br/>
>> Client mengirim request ke Server secara berkala untuk melihat apakah ada Data baru, jika ada, maka Server melakukan Respond dengan memberi Updated Information. <br/>
>> 
>> Polling dapat menambah Beban Server (Server Load) dan Menyebabkan Inefficiency (ketidak efisienan) karena Server tidak selalu mempunyai Data terbaru saat Polling >> >> >> dilakukan, sehingga Polling dapat membuang Resources (seperti Bandwith) secara  Mubazir. <br/>
>> <br/>
>> Polling juga bisa menyebabkan Latency, yakni dalam hal keterlambatan pengiriman Update Data, karena Client hanya mengecek Data terbaru pada Spesifik Interval (jangka >> >> waktu tertentu). Sehingga jika kita menetapkan Pengecekkan dilakukan setiap Interval waktu yang panjang, maka Data terbaru tersebut dapat terlambat sampai ke User. <br/>
>> <br/>
>> Untuk mengatasi hal tersebut, terdapat beberapa Alternative, diantaranya adalah : <br/> 
>> 
>> - Long Polling : <br/>
>> Client membuat sebuah Request dan Server menahan untuk belum memberikan Response terhadap Request tersebut sampai terdapat Data baru. <br/>
>> hal ini bertujuan untuk mengurangi jumlah Request yang tidak perlu. <br/> <br/>
>> 
>> - WebSockets : <br/>
>> Cara yang lebih efisien untuk menjaga Koneksi tetap terjalin antara Client & Server, <br/>
>> sehingga memungkinkan agar Data Terbaru dapat langsung dikirimkan secara instan, tanpa perlu membuat Request yang berulang. <br/> <br/>
>>
>> -> Contoh "Traditional HTTP Request" : <br/> <br/>
>> 
>> Misalnya kita membuka Halaman Web : <br/>
>> 
>> (1) Kita (Client) mengetikkan URL ke Browser (seperti www.xyz.com). <br/>
>> (2) Browser mengirimkan "HTTP GET Request" ke Server yang meng-hosting Website tersebut. <br/>
>> (3) Server memproses Request dan memberikan Response dengan mengirim WebPage Content yang diminta oleh Client. <br/>
>> (4) Browser menampilkan Halaman Web, dan Connection ditutup. <br/>
>> karena Connection ditutup, sehingga jika terdapat Perubahan (Update) pada Content Halaman Website, kita perlu Refresh Halaman Web untuk mendapatkan Update pada Content >> halaman Web tersebut. <br/>
>>
--------

## B. Subgraphs

 -> Subgraph merupakan semua Metadata yang dibutuhkan untuk bertindak sebagai Self-Contained Entity (Entitas Mandiri) yang dapat dibuat, dimiliki, dipelihara, dan dibangun secara independen oleh Team Individu, untuk kemudian menjadi bagian yang saling terhubung dari Unified API

-> untuk API Authors (penulis API), ini berarti kemampuan untuk membangun API yang terdiri dari berbagai Sumber dengan cara yang sederhana dan deklaratif.
kita dapat memanfaatkann aturan kontrol akses (access-control) yang unik, Mekanisme Autentikasi, dan Custom Business Logic dalam Subgraph kita untuk membuat API yang aman & tangguh.



